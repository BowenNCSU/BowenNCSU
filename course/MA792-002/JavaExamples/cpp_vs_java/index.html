
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with jLaTeX2HTML 2002 (1.62) JA patch-1.4
patched version by:  Kenshi Muto, Debian Project.
LaTeX2HTML 2002 (1.62),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Erich's Java cheat sheet for C++ programmers</TITLE>
<META NAME="description" CONTENT="Erich's Java cheat sheet for C++ programmers">
<META NAME="keywords" CONTENT="cpp_vs_java">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="jLaTeX2HTML v2002 JA patch-1.4">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="cpp_vs_java.css">

</HEAD>

<BODY >

<H1 ALIGN="CENTER">Erich's Java cheat sheet for C++ programmers</H1>
<P ALIGN="CENTER"><STRONG>&#169;
<A NAME="tex2html1"
  HREF="http://www.math.ncsu.edu/~kaltofen/index.html">Erich Kaltofen</A>
<BR><TT>kaltofen@math.ncsu.edu</TT></STRONG></P>

<P>
Text versions:
<A NAME="tex2html7"
  HREF="http://www.math.ncsu.edu/~kaltofen/courses/Languages/JavaExamples/cpp_vs_java.ps.gz">gzipped postscript</A>,
<A NAME="tex2html8"
  HREF="http://www.math.ncsu.edu/~kaltofen/courses/Languages/JavaExamples/cpp_vs_java.pdf">pdf</A>.

<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">
<B>C++</B></TD>
<TD ALIGN="LEFT"><B>Java</B></TD>
</TR>
<TR><TD ALIGN="LEFT">assignment <TT>operator=</TT></TD>
<TD ALIGN="LEFT">cannot be user-defined for
  a class and performs assignment of a reference to the
  instance of the class (see also reference types)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>basic</TT><code>_</code><TT>string</TT></TD>
<TD ALIGN="LEFT"><TT>String</TT> and <TT>StringBuffer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>bool</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>char</TT></TD>
<TD ALIGN="LEFT"><TT>byte</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>const</TT> variables/data members</TD>
<TD ALIGN="LEFT"><TT>final</TT> variables/fields</TD>
</TR>
<TR><TD ALIGN="LEFT">copy constructor</TD>
<TD ALIGN="LEFT">no default; one implements the interface
  <TT>Cloneable</TT> by the method
  <TT>Object clone()</TT>, which can be an abstract (in C++ notion: virtual)
  method</TD>
</TR>
<TR><TD ALIGN="LEFT">data members</TD>
<TD ALIGN="LEFT">fields, so-called <I>instance variables</I>
  (a term borrowed from Smalltalk)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>delete</TT></TD>
<TD ALIGN="LEFT">does not exist; all unreferenced memory
  is garbage collected</TD>
</TR>
<TR><TD ALIGN="LEFT">derived classes</TD>
<TD ALIGN="LEFT">subclasses; the keyword
  <TT>extends</TT> replaces C++'s colon.</TD>
</TR>
<TR><TD ALIGN="LEFT">destructors <TT>~</TT><I>Class</I></TD>
<TD ALIGN="LEFT"><TT>protected void finalize()</TT>; note, however,
  that these are used for freeing resources
  <B>other than memory</B> and are therefore
  rarely needed</TD>
</TR>
<TR><TD ALIGN="LEFT">exceptions, <TT>try</TT>, <TT>catch</TT>, <TT>throw</TT>,
  <TT>std:exception</TT></TD>
<TD ALIGN="LEFT">same concept; Java adds a keyword <TT>throws</TT> that
  is used to declare the exceptions a method throws;
  the hierarchy of exceptions is rooted in
  <TT>java.lang.Exception</TT>;
  a <TT>finally</TT> block is introduced to contain
  all common clean-up code.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>extern "C"</TT> functions</TD>
<TD ALIGN="LEFT"><TT>native</TT> methods</TD>
</TR>
<TR><TD ALIGN="LEFT">functions</TD>
<TD ALIGN="LEFT">do not exist; <TT>static</TT> methods (``class
            methods'') are used</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>#include</TT></TD>
<TD ALIGN="LEFT">does not exist;
the paths to the files are known and can be
made know in the <TT>CLASSPATH</TT> environment
variable</TD>
</TR>
<TR><TD ALIGN="LEFT">input/output: <TT>istream&amp; operator&#187;</TT>,
   <TT>ostream&amp; operator&#171;</TT></TD>
<TD ALIGN="LEFT"><TT>System.in</TT> and <TT>System.out</TT> are the streams;
   Java has number formatting tools in
   <TT>java. lang. Number</TT>
   and <TT>java. text. Format. NumberFormat</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>main(int argc, char* argv[])</TT></TD>
<TD ALIGN="LEFT"><TT>public static void main(String [] args)</TT>
    within a <TT>public</TT> class</TD>
</TR>
<TR><TD ALIGN="LEFT">member functions</TD>
<TD ALIGN="LEFT">methods</TD>
</TR>
<TR><TD ALIGN="LEFT">multiple inheritance</TD>
<TD ALIGN="LEFT">does not exist; however,
interfaces provide a weak form of multiple inheritance.</TD>
</TR>
<TR><TD ALIGN="LEFT">namespaces</TD>
<TD ALIGN="LEFT">packages</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>namespace </TT><I>Namespace</I><code>{</code>...<code>}</code></TD>
<TD ALIGN="LEFT"><TT>package</TT><I>Package</I><TT>;</TT> which must appear
     as the first line in the file</TD>
</TR>
<TR><TD ALIGN="LEFT">nested (member, inner) classes</TD>
<TD ALIGN="LEFT">Java&nbsp;1.1 has <TT>static</TT> (``top-level'')
  and non-static (``member'') inner classes, as well
  as local classes and anonymous classes. Member classes
  can refer to the members of the outer class
  and to <I>OuterClass</I><TT>.this</TT>;
  they cannot have the name of an outer class
  and cannot declare <TT>static</TT> members.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>new</TT> <I>Class</I><TT>(</TT>...<TT>)</TT></TD>
<TD ALIGN="LEFT"><TT>new</TT> <I>Class</I><TT>(</TT>...<TT>)</TT>, which
   returns a reference to the created object</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>NULL</TT> (the 0 pointer value) and the type
  <TT>void*</TT></TD>
<TD ALIGN="LEFT"><TT>null</TT> in Java is a keyword and
  represents an uninitialized reference</TD>
</TR>
<TR><TD ALIGN="LEFT">overloaded operators</TD>
<TD ALIGN="LEFT">do not exist; however, methods
  can be overloaded.  This may be a major shortcoming of
  Java, as one cannot revise old Java code by redefining
  the operators used (cf. MITMatlab)</TD>
</TR>
<TR><TD ALIGN="LEFT">passing arguments to base class constructor</TD>
<TD ALIGN="LEFT">place the statement <TT>super(</TT>...<TT>);</TT> as the
  first statement in the subclass's constructor</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>public</TT>, <TT>private</TT>, <TT>protected</TT> modifiers</TD>
<TD ALIGN="LEFT">similar as in C++; visibility of classes and nested classes can
  be also restricted; there are no friends, but within the same package
  protected members are visible</TD>
</TR>
<TR><TD ALIGN="LEFT">purely <TT>virtual</TT> member functions</TD>
<TD ALIGN="LEFT"><TT>abstract</TT> methods; the enclosing class
  must also be declared <TT>abstract</TT></TD>
</TR>
<TR><TD ALIGN="LEFT">reference types <I>Type</I><TT>&amp;</TT></TD>
<TD ALIGN="LEFT">all Java types except scalar primitive types
  are reference types; note that the
  method
<BR>
  <TT>void swap(</TT><I>T</I> <TT>a, </TT><I>T</I><TT>b)</TT>
  <code>{</code><I>T</I> <TT>t; t = a; a = b; b = t;</TT><code>}</code>
<BR>
does nothing to its arguments.</TD>
</TR>
<TR><TD ALIGN="LEFT">scope resolution, operator <TT>::</TT></TD>
<TD ALIGN="LEFT">does not exist;  methods must be defined inside the class
  declaration.  If a base class field is to be
  explicitly referred, one uses typecasting:
  <TT>((</TT><I>Baseclass</I><TT>)</TT><I>Variable</I><TT>).</TT><I>Member</I>;
  a direct base class member can be referred to by
  <TT>super.</TT><I>Member</I>;
  typecasting has no effect on methods (see <TT>virtual</TT> member functions).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>static</TT> data members</TD>
<TD ALIGN="LEFT"><TT>static</TT> fields, so-called
  <I>c</I>lass variables; they are
  accessed by <I>Class</I><TT>.</TT><I>Field</I> rather than
  the C++ <I>Variable</I><TT>.</TT><I>Member</I>; they can
  be initialized by <TT>=</TT>...<TT>;</TT> within
  the class definition and need not be declared outside
  like C++ static data members.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>static</TT> member functions</TD>
<TD ALIGN="LEFT"><TT>static</TT> methods,
  so-called <I>class methods</I>; they are defined
  within the class declaration, unlike in C++.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>this</TT></TD>
<TD ALIGN="LEFT"><TT>this</TT>, which is a reference to the
  object and has the type of the class,
  not a pointer; note that the call <TT>this(...);</TT> as
  the first statement in a constructor invokes a
  constructor call for the matching argument types.</TD>
</TR>
<TR><TD ALIGN="LEFT">traits</TD>
<TD ALIGN="LEFT">marker interfaces</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>type</TT><code>_</code><TT>id</TT></TD>
<TD ALIGN="LEFT"><TT>instanceof</TT>; this is an operator
   returning a <TT>boolean</TT>, not a ``<TT>type</TT><code>_</code><TT>info</TT>'' as
   in C++.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>using namespace</TT> <I>Package</I><TT>;</TT></TD>
<TD ALIGN="LEFT"><TT>import</TT> <I>Package</I><TT>.*;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>virtual</TT> member functions</TD>
<TD ALIGN="LEFT">in Java, all methods use dynamic method lookup
    and therefore are be default virtual. There is no way
    to explicity call an overridden base class method,
    but overwriting can be prevented by declaring a
    method <TT>final</TT>.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>wchar</TT><code>_</code><TT>t</TT></TD>
<TD ALIGN="LEFT"><TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT">wide character stream <TT>wostream</TT></TD>
<TD ALIGN="LEFT"><TT>PrintWriter</TT> replaces <TT>PrintStream</TT> 
   that cannot hold unicode;
   the constructor of <TT>PrintStream</TT> has been
   deprecated in Java 1.1, but <TT>System.out</TT> is not.</TD>
</TR>
</TABLE>

<P>

<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Java concepts missing in C++</B></TD>
</TR>
<TR><TD ALIGN="LEFT">abstract windows toolkit AWT</TD>
<TD ALIGN="LEFT">standard library for building a GUI</TD>
</TR>
<TR><TD ALIGN="LEFT">concatenation of strings by <TT>+</TT> operator</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">documentation comments</TD>
<TD ALIGN="LEFT">can be processed (e.g., by <TT>javadoc</TT>)
   for automatic online documentation</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>final</TT> methods</TD>
<TD ALIGN="LEFT">those cannot be overridden by a subclass</TD>
</TR>
<TR><TD ALIGN="LEFT">interfaces</TD>
<TD ALIGN="LEFT">are used to denote abstract classes without any
   method of their own. They can have <TT>static final</TT> fields.
   One class can implement several interfaces, but it
   must implement the abstract methods of each interface.</TD>
</TR>
<TR><TD ALIGN="LEFT">reflection</TD>
<TD ALIGN="LEFT">allows the inspection of a class
   (which arguments does which member take? etc.);
   this is critical for plug-and-play design, such
   as a Java bean</TD>
</TR>
<TR><TD ALIGN="LEFT">right shift operator with zero extension <TT>&gt;&gt;&gt;</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">serialization</TD>
<TD ALIGN="LEFT">C++ requires the programmer to implement object
   serialization member functions</TD>
</TR>
<TR><TD ALIGN="LEFT">sockets</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">threads</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
</TABLE>

<P>

<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" COLSPAN=2><B>C++ concepts missing in Java</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>const</TT> member functions</TD>
<TD ALIGN="LEFT">do not exist; <TT>final</TT> methods cannot be
  overridden by subclasses</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>friend</TT> classes, functions</TD>
<TD ALIGN="LEFT">do not exist; however, <TT>protected</TT> members are visible
  within the same package</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>goto</TT></TD>
<TD ALIGN="LEFT">is a reserved work in Java, but is not supported by
  the language; however <TT>break</TT> and <TT>continue</TT>
  statements can give a statement label</TD>
</TR>
<TR><TD ALIGN="LEFT">multiple inheritance</TD>
<TD ALIGN="LEFT"><TT>virtual</TT> base classes seem
  unachievable by using interfaces</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>new(</TT><I>Pointer</I><TT>) </TT><I>Type</I><TT>(</TT>...<TT>);</TT>
<I>Pointer</I><TT>-&gt;</TT><code>~</code><I>Type</I><TT>();</TT></TD>
<TD ALIGN="LEFT">this is C++'s explicit memory allocation mechanism.
  In Java, all memory is managed by the VM and garbage collection
  is automatic.  Thus, in C++, a garbage collector can be implemented,
  while in Java a memory manager cannot.&#182;</TD>
</TR>
<TR><TD ALIGN="LEFT">pointer types <I>Type</I><TT>*</TT></TD>
<TD ALIGN="LEFT">do not exist; actually, since
  Java has only reference types, all variables are some kind
  of pointers and the <TT>=</TT> operator behaves like a
  pointer assignment</TD>
</TR>
<TR><TD ALIGN="LEFT">pointer to function, member</TD>
<TD ALIGN="LEFT">not a serious restriction,
  as one may encapsulate a function in a function object</TD>
</TR>
<TR><TD ALIGN="LEFT">standard template library STL</TD>
<TD ALIGN="LEFT"><TT>java.util.Vector</TT> provides an expandable vector.
  Java 1.2 provides
<A NAME="tex2html2"
  HREF="http://java.sun.com/products/jdk/1.2/docs/guide/collections/index.html"><TT>Collection</TT>s</A>,

which are essentially  C++ STL containers, but many of the members are
  renamed.
  Note that <TT>List</TT> is a scrollable list in the AWT.
  There are third-party vendor container packages: See
<A NAME="tex2html3"
  HREF="http://reality.sgi.com/austern_mti/java/index.html"><TT>http://reality.sgi.com/
austern_mti/java/index.html</TT></A>,
<A NAME="tex2html4"
  HREF="http://www.objectspace.com/developers/jgl/downloads/index.html"><TT>http://www.objectspace.
com/developers/jgl/downloads/index.html</TT></A>&#167;</TD>
</TR>
<TR><TD ALIGN="LEFT">templates</TD>
<TD ALIGN="LEFT">there is a the GJ compiler 
<A NAME="tex2html5"
  HREF="http://www.cs.bell-labs.com/~wadler/pizza/gj/"><TT>http://www.cs.bell-labs.
com/~wadler/pizza/gj/</TT></A>.&#167;  C++'s
template expansion mechanism is a full-fledged programming
language and has been used for compiler optimization task
(e.g., in the
<A NAME="tex2html6"
  HREF="http://oonumerics.org/blitz/">Blitz++</A>
matrix library)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>typedef</TT></TD>
<TD ALIGN="LEFT">asside as a shorthand, <TT>typedef</TT>s
   can be encapsulated in a class scope to provide a
   generic type; they function as
   assignments in template meta-programming.</TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2>&#182;Laurent Bernardin points out that this isn't exactly
true: place all objects on arrays/lists for reuse</TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2>&#167;These references were provided by Thierry Gautier</TD>
</TR>
</TABLE>

<P>

<H1><A NAME="SECTION00010000000000000000">
About this document ...</A>
</H1>
 <STRONG>Erich's Java cheat sheet for C++ programmers</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002 (1.62)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-ascii_mode -split 0 -no_navigation cpp_vs_java.tex</TT>
<P>
The translation was initiated by Erich Kaltofen on 2002-11-04
<BR><HR>
<ADDRESS>
Erich Kaltofen
2002-11-04
</ADDRESS>
</BODY>
</HTML>
